-- Create a table for Public Profiles
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  "name" text,
  full_name text,
  avatar_url text,
  email text,
  primary key (id)
);
alter table profiles enable row level security;
create policy "Public profiles are viewable by everyone." on profiles for
select using (true);
create policy "Users can insert their own profile." on profiles for
insert with check (auth.uid() = id);
create policy "Users can update own profile." on profiles for
update using (auth.uid() = id);
-- Create a trigger to sync profiles and auth.users
create function public.handle_new_user() returns trigger as $$ begin
insert into public.profiles (id, full_name, avatar_url)
values (
    new.id,
    new.raw_user_meta_data->>'name',
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url'
  );
return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
after
insert on auth.users for each row execute procedure public.handle_new_user();
-- VIEWCOUNTER
CREATE TABLE pageviews (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  slug text UNIQUE NOT NULL,
  view_count bigint DEFAULT 1 NOT NULL
);
CREATE OR REPLACE FUNCTION increment_page_view(page_slug TEXT) RETURNS void LANGUAGE plpgsql AS $$ BEGIN IF EXISTS (
    SELECT
    FROM pageviews
    WHERE slug = page_slug
  ) THEN
UPDATE pageviews
SET view_count = view_count + 1,
  WHERE slug = page_slug;
ELSE
INSERT into pageviews(slug)
VALUES (page_slug);
END IF;
END;
$$;
-- GUESTBOOK//HOTLINE BLING
create table hotline (
  id bigint generated by default as identity primary key,
  posted_at timestamp with time zone,
  body text,
  author_id uuid not null references profiles (id),
  parent_id bigint NULL references hotline (id) on delete cascade
);
