---
title: Getter Pattern Framer Motion
description: How to use onanimationend to animate to and from display none with Framer Motion.
date: 2022-11-01
---

<Image
  src="/img/alex-bryce-next-mdx-remote.png"
  width="1200"
  height="720"
  alt="Implementing next-mdx-remote server components on a Next.js project"
/>

SWR uses a clever technique to `reduce` the number of re-renders in components that share state. Just like [state selectors](https://github.com/pmndrs/zustand#selecting-multiple-state-slices), it stems from this idea: if you never use a certain value, why re-render when that unused value changes?
For example:

```tsx
const { data } = useSWR();

// useSWR also returns `error`, but it's unused here
// No need to re-render when `error` changes
```

Instead of selector callbacks, SWR uses JavaScript [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) to detect when values are being read, and will only re-render for relevant changes. This trick only applies if your state is shared and object-like – which happens to be a majority of state and context in React apps.
**[Implementation](https://paco.me/writing/hook-getter#implementation)**

I wrote a [collection of concepts](https://github.com/pacocoursey/state) that implement this pattern with a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy). Here’s the general idea:

- Keep state outside of render lifecycle (could be ref, or global)
- State returned from the hook is actually a proxy
- When proxy `get` is invoked: track which object key is used, return the value
- When proxy `set` is invoked: update state, broadcast to all listeners
- In each hook, listen for broadcast but only re-render if the changed key is tracked

Let’s model our _state solution_ after Zustand, where you create state _stores_ outside of render:

```tsx
const useStore = createStore({
  name: "John",
  username: "johndoe",
});

function NameDisplay() {
  const state = useStore();

  // Should only re-render when state.name changes, as username is unused
  return (
    <input value={state.name} onChange={(e) => (state.name = e.target.value)} />
  );
}
```

When creating a store, we’ll track the state and any listeners. When each hook subscribes to the shared state, we just add it to a set of listeners.

```tsx
function createStore(initial = {}) {
  const state = initial;
  const listeners = new Set();

  function subscribe(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
}
```

Setting state checks for equality and broadcasts to any listeners if the state changed:

```tsx
function setState(key, value) {
  if (!Object.is(state[key], value)) {
    state[key] = value;
    listeners.forEach((listener) => listener(state, key));
  }
}
```

Finally, creating the store returns a hook to actually use the store. It creates a proxy that updates a `tracked` ref on any `get` access, and calls `setState` for any `set` access.

`return proxy`
That’s about it, a simple shared state system in about 50 lines. Full [code is here](https://github.com/pacocoursey/state).

**Shine, constantly and steadily**
